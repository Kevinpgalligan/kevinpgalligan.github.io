<!doctype html>
<html lang="en">

<head>
    <title> Random RGB values that average to N; or, fun with probability and combinatorics </title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="/pygments.css">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/img/favicon-16x16.png">
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-147419708-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-147419708-1');
    </script>
    
</head>

<body>
    <header>
        <div data-nosnippet>
        <div class="banner"><h1>kevingal.com</h1></div>
        
        <nav>
        
            <a href="/index.html" class="navlink">home</a>
        
            <a href="/blog.html" class="navlink" id="active-page-navlink">blog</a>
        
            <a href="/projects.html" class="navlink">projects</a>
        
        </nav>
        </div>
    </header>

<h2>Random RGB values that average to N; or, fun with probability and combinatorics</h2>
<p>On this episode of Problems That Don't Need to Be Solved, we have a doozy from r/computerscience.</p>
<blockquote>
<p><a href="https://www.reddit.com/r/computerscience/comments/a1ea1s/create_program_to_generate_random_rgb_values_that/">"Generate a random RGB value where the average of R, G and B is A, A being an integer from 0-255."</a></p>
</blockquote>
<p>In other words, we have to generate a random RGB value so that (R+G+B)/3=A. Solving this seemingly simple problem, we'll tackle some neat <a href="https://en.wikipedia.org/wiki/Combinatorics">combinatorics</a> and see how difficult it is to test algorithms involving randomness.</p>
<h3>An attempt</h3>
<p>The first algorithm that might come to mind is the following. We generate random values for R, G and B one at a time, ensuring at each step that 0&lt;=R,G,B&lt;=255 and that it's still possible to satisfy (R+G+B)/3=A, i.e. R+G+B=3A.</p>
<p>Here it is in Python code.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">random</span> <span class="kn">as</span> <span class="nn">rd</span>
<span class="k">def</span> <span class="nf">generate_rgb</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">S</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">A</span>
    <span class="c1"># Generate a random value for R, ensuring that:</span>
    <span class="c1">#  1) 0 &lt;= R &lt;= 255</span>
    <span class="c1">#  2) R &lt;= 3A</span>
    <span class="c1">#  3) R &gt;= 3A - 2*255</span>
    <span class="c1"># We need #3 because otherwise, even with G=B=255, we&#39;d</span>
    <span class="c1"># have R+G+B&lt;3A and the average of R, G, B would be less than A.</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
    <span class="n">S</span> <span class="o">-=</span> <span class="n">R</span>
    <span class="c1"># Similar conditions to satisfy for G.</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
    <span class="n">S</span> <span class="o">-=</span> <span class="n">G</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">S</span>
    <span class="k">return</span> <span class="n">R</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">B</span>
</pre></div>


<p>This approach seems reasonable, and if we run a test that checks whether the resulting RGB values have an average of A, it passes with flying <font color="red">c</font><font color="orange">o</font><font color="yellow">l</font><font color="green">o</font><font color="blue">u</font><font color="pink">r</font><font color="purple">s</font>.</p>
<div class="codehilite"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rgbs</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_rgb</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">)]</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;PASS&quot;</span> <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">rgb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="o">*</span><span class="n">A</span> <span class="k">for</span> <span class="n">rgb</span> <span class="ow">in</span> <span class="n">rgbs</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;FAIL&quot;</span><span class="p">)</span>
<span class="c1"># output: PASS</span>
</pre></div>


<p>However, this doesn't give us the full picture. Besides ensuring that R+G+B=3A, we also need to check that all of the possible RGB values are equally likely to appear, since the problem statement requires randomness. Graphing the frequency of the possible values, we see that this is not the case.</p>
<p><img alt="distribution of RGB values" src="/static/img/rgb-average/rgb-value-distribution-broken.png" /></p>
<p>(3, 0, 0) is the most likely value by far at ~25%. This is because P(R=3) -- the probability that R=3 -- is, according to our algorithm, 1/4. And when R=3, the only valid value we can assign to G &amp; B is 0 (otherwise, R+G+B&gt;3A), forcing an RGB value of (3, 0, 0). Meanwhile, there are multiple possible RGB values for each of R=0, R=1 and R=2 that have to share their 1/4 slices of probability pie. (3, 0, 0) ends up with a disproportionately high probability of being chosen.</p>
<p>It was difficult to catch this error. R+G+B=3A can be checked directly, but the randomness of the solution cannot. At least, not easily. We had to run the code 1000s of times and then visualise the output.</p>
<h3>Well, I'll be damned! What's the darn-tootin' solution, then?</h3>
<p>The possible values of R are not equally likely. For example, in the case where A=1, P(R=3) &lt; P(R=1), because R=3 is only possible when (G,B)=(0,0) (10%), whereas R=1 is possible when (G,B) is any of (0,2), (2,0) or (1,1) (30%).</p>
<p>Hence, before picking R at random, we have to calculate the probability of each of its possible values. P(R=r) for some r is given by #{GB values that sum to 3A-r} / #{RGB values that average to A}.</p>
<p>Let's consider the numerator and the denominator separately. Here's the value of #{GB values that sum to 3A-r}:</p>
<p><img alt="numerator formula, min(3A-r, 255) - max(3A-r-255, 0) + 1" src="/static/img/rgb-average/equation-1-numerator.png" /></p>
<p>We subtract the minimum value that G can take from the maximum value it can take, then add 1 because it's an inclusive range (the length of a range of integers A&lt;=i&lt;=B is B-A+1). Note: the number of possible G values is the same as the number of possible GB values, since every G value has only 1 corresponding B that goes with it. </p>
<p>To convince yourself that this is correct, consider A=87, 3A=261 and r=1. We have 3A-r=260. The possible GB values are (255,5), (254, 6), ..., (5, 255). There are 251 such values. This agrees with the expression above. Repeat for various values of A and r.</p>
<p>Now we need to calculate the denominator of P(R=r): #{RGB values that average to A}. The expression is below. It looks scary, but we'll explain each part in an intuitive manner.</p>
<p><img alt="denominator formula, binom(3A+3-1, 2) - 3 * binom(3A+3-1-256, 2) + 3 * binom(3A+3-1-2*256, 2)" src="/static/img/rgb-average/equation-2-denominator.png" /></p>
<p>The first part, <strong>in black</strong>, is the number of ways to divide 3A between R, G and B. The () syntax represents the "binomial coefficient" function, which can also be written as nCk: <a href="https://en.wikipedia.org/wiki/Binomial_coefficient">"the number of ways to choose an (unordered) subset of k elements from a fixed set of n elements"</a>. Above, we have <strong>{3A+3-1}C{2}</strong>, or "the number of ways to choose 2 things from 3A+3-1 things".</p>
<p>Why do we need this binomial coefficient thing? Let's consider an example where A=2, 3A=6. Imagine that we have the numbers 1-6 lined up with spaces between them. We have to put "partitions" in 2 of the spaces in order to divide 3A=6 between R, G and B, as seen below.</p>
<p><img alt="visualisation of partitioning of 3A" src="/static/img/rgb-average/comb-explained-1.png" /></p>
<p>Here, R=2, G=3 and B=1. We have 3A-1 = 5 spaces, and we have to insert partitions into 2 of them, which gives {3A-1}C{2} possible combinations.</p>
<p>HOWEVER, to complete the <strong>first part</strong> we also have to account for the case where any of R, G or B are 0. For that reason, we need 3 extra spaces acting as flags that let us set each of R, G and B to 0. If we put a partition in one of these spaces, it means that the corresponding R/G/B is set to 0.</p>
<p>Here we see an illustration of G=0.</p>
<p><img alt="visualisation of partitioning of 3A, part 2" src="/static/img/rgb-average/comb-explained-2.png" /></p>
<p>And here, R=0 and B=0.</p>
<p><img alt="visualisation of partitioning of 3A, part 3" src="/static/img/rgb-average/comb-explained-3.png" /></p>
<p>To conclude: including the zero flags, we need 3A-1+3 spaces, of which we pick 2. And like that, we can make sense of the <strong>first part</strong> of the expression, <strong>{3A-1+3}C{2}</strong>.</p>
<p>We need the <font color="blue">second part</font> of the expression because, in the <strong>first part</strong>, we unwittingly allowed R&gt;255, G&gt;255 and B&gt;255. The intuition is the same as the <strong>first part</strong>, except we remove 256 numbers and assign them to one of R, G or B. The remaining 3A-1+3-256 spaces are divided among R, G and B like before, by inserting partitions into 2 spaces, and there are <font color="blue">{3A-1+3-256}C{2}</font> ways to do this. And we multiply by 3 for the 3 cases: R&gt;255, G&gt;255 and B&gt;255.</p>
<p>Here's an example where 3A=264. We give R a base value of 256, then partition the remaining values like we did before. If we "enabled" the R=0 flag, then the final value of R would just be 256.</p>
<p><img alt="partitioning of 3A when R&gt;255" src="/static/img/rgb-average/comb-explained-4-r-gt-255.png" /></p>
<p>The <font color="red">final part</font> of the expression is needed because, in the <font color="blue">second part</font>, we double-subtracted the case where more than one of R, G and B are greater than 255. First we subtracted combinations where R&gt;255, which includes combinations where G&gt;255. Then we subtracted combinations where G&gt;255, which includes combinations where R&gt;255. In the end we've double-subtracted the combinations where R&gt;255 as well as G&gt;255.</p>
<p>In this example, 3A=519. We set aside 256 numbers for R and 256 numbers for G, then partition the remaining 7 numbers between R, G &amp; B like before.</p>
<p><img alt="partitioning of 3A when R&gt;255 and G&gt;255" src="/static/img/rgb-average/comb-explained-5-rg-gt-255.png" /></p>
<p>There are 3A+3-1-2*256 spaces, of which we pick 2. There are <font color="red">{3A+3-1-2*256}C{2}</font> ways to do this. Multiply by 3 because there are 3 different pairs of R, G &amp; B that can both be &gt;255, and out pops the <font color="red">final part</font>.</p>
<p>Having derived all 3 parts, we can now calculate #{RGB values that average to A}, which in turn lets us calculate P(R=r). This is the key to our final algorithm. We use a weighted random choice to pick R, based on P(R=r). After that, G and B can be determined from an unweighted random choice like in the "first attempt" algorithm.</p>
<p>Here it is in Python code.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">random</span> <span class="kn">as</span> <span class="nn">rd</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>

<span class="k">def</span> <span class="nf">generate_rgbs</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">S</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">A</span>
    <span class="n">num_rgbs</span> <span class="o">=</span> <span class="n">num_rgbs_that_sum_to</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="c1"># R can&#39;t be smaller than 3A - 2*255. Otherwise, even with G = B = 255, we will have:</span>
    <span class="c1">#   R + G + B = (3A - 2*255 - blah) + 255 + 255 = 3A - blah &lt; 3A.</span>
    <span class="c1"># Similarly, R can&#39;t be bigger than 3A.</span>
    <span class="c1"># We also need to ensure that R is in the range [0, 255].</span>
    <span class="n">R_possible_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">R_probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_gbs_that_sum_to</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_rgbs</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">R_possible_values</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">generate_rgb</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">R_possible_values</span><span class="p">,</span> <span class="n">R_probabilities</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">num_rgbs_that_sum_to</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Outputs number of RGB tuples that sum to &#39;S&#39;.&quot;&quot;&quot;</span>
    <span class="n">K</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1"># R, G, B</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">comb</span><span class="p">(</span><span class="n">S</span> <span class="o">+</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Remove cases where R, G or B are &gt;255, since</span>
        <span class="c1"># these are not allowed.</span>
        <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">S</span> <span class="o">+</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">256</span><span class="p">,</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Re-add the case where &gt;1 of R, G and B are &gt;255, since</span>
        <span class="c1"># they were subtracted twice in the previous bit.</span>
        <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">S</span> <span class="o">+</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">256</span><span class="p">,</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">num_gbs_that_sum_to</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">generate_rgb</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">R_possible_values</span><span class="p">,</span> <span class="n">R_probabilities</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates R,G,B that sum to S given pre-computed probabilities</span>
<span class="sd">    for possible R values.&quot;&quot;&quot;</span>
    <span class="n">R</span><span class="p">,</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="n">R_possible_values</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">R_probabilities</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">-=</span> <span class="n">R</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
    <span class="n">S</span> <span class="o">-=</span> <span class="n">G</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">S</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>


<p>Besides generating valid RGB values, all of the possible RGB values for A=245 seem to have an equal probability of being generated.</p>
<p><img alt="distribution of RGB values" src="/static/img/rgb-average/rgb-value-distribution.png" /></p>
<h3>Conclusion</h3>
<p>We've battled through the combinatorics and come out the other side with a working algorithm, along the way witnessing the peril of testing randomised algorithms.</p>
<p>Tune in for the next episode of Problems That Don't Need to Be Solved, where we'll be looking at Rubix Cubes.</p>
<h3>Homework</h3>
<ul>
<li>Generate random RGB values directly from the sequence of valid values rather than going through the rigmarole of calculating probability distributions. In other words, if there are N possible RGB values, we generate a random number 'k' between 1 and N and pass it to our magic function 'f' so that f(k) outputs the kth valid RGB value.</li>
<li>Create a generic version of the algorithm that generates random tuples of integers, with arbitrary bounds on the values of the integers. More formally, the task would be to generate a random tuple V = (V1, V2, ..., Vn) such that (V1+V2+...+Vn)/n = A, where Bl &lt;= Vi, A &lt;= Bu. The combinatorics behind this would be similar to what we did above.</li>
</ul>
<hr>
<p><i>Post Date: 2019-11-18</i></p>
<div class="previous-page-link">
 Previous: <a href="/blog/potter-puzzle.html">Solving all 42 versions of the Harry Potter potions puzzle</a>

</div>
<div class="next-page-link">
 <p>No next article.</p>

</div>


</body>
</html>