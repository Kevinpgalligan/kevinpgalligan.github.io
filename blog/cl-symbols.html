<!doctype html>
<html lang="en">

<head>
    <title>An Earnest Guide to Symbols in Common Lisp</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/static/css/style.css">
    

<meta property="og:description" content="...with an emphasis on exploratory programming and examples." /> 
<meta property="og:image" content="https://kevingal.com/static/img/thumbnail.jpg" />
<meta name="thumbnail" content="/static/img/thumbnail.jpg" />

<link rel="stylesheet" href="/static/css/pygments.css">

<meta property="description" content="...with an emphasis on exploratory programming and examples.">

<link rel="stylesheet" href="/static/css/blog.css">

    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon.ico">
</head>
<body>
    <header>
        <div data-nosnippet class="navbar">
        <nav>
        <a href="/index.html" class="navlink">about</a>
        • <a href="/blog.html" class="navlink">blog</a>
        • <a href="/projects.html" class="navlink">projects</a>
        • <a href="/feed.xml" class="navlink">rss</a>
        </nav>
        </div>
    </header>

<h2 class="post-title">An Earnest Guide to Symbols in Common Lisp</h2>
<h3 class="post-date">2025-06-04</h3>
<h3 class="post-date">...with an emphasis on exploratory programming and examples.</h3>
<p>Tags: <a href="/blog/tag/lisp.html">lisp</a> <a href="/blog/tag/programming.html">programming</a> </p>
<a href="/blog/cl-livecoding.html">&lt;&lt; previous</a>
<hr>
<p>Lisp programs have an extremely simple syntax, where everything is either a list or an atom. The most common type of atom is the <strong>symbol</strong>, which is used to give names to things like variables and functions. In the Common Lisp code below, <code>defun</code>, <code>pie</code>, <code>let</code>, <code>+</code>, <code>x</code> and <code>y</code> are all symbols.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">pie</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">y</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
</code></pre></div>

<p>The symbol might be a simple data structure, but its interaction with other parts of Common Lisp - packages, the Lisp Reader, macros - is complicated. This article is a vaguely FAQ-like exploration of symbols and packages that will hopefully illuminate some of these tricky interactions. Worth reading before, after, or in parallel, is (PDF warning) <a href="https://flownet.com/ron/packages.pdf">The Complete Idiot's Guide to Common Lisp Packages</a>.</p>
<figure>

<img src="/static/img/cl-packages/cl-user.png"
     alt="A box labelled 'common-lisp-user', with a stick figure inside and two symbols, 'car' and 'cdr'.."
     class="centered">
<figcaption>The common-lisp-user package and some of the symbols it contains.</figcaption>
</figure>

<h2>Table of Contents</h2>
<div class="toc">
<ul>
<li><a href="#what-is-a-symbol">What is a symbol?</a></li>
<li><a href="#what-is-to-be-done-with-symbols">What is to be done... with symbols?</a></li>
<li><a href="#why-is-the-symbol-name-in-all-caps">Why is the symbol name in all-caps?</a></li>
<li><a href="#_-is-a-symbol">&lt;_%&amp;? is a symbol</a></li>
<li><a href="#the-secrets-of-the-defun">The secrets of the defun</a></li>
<li><a href="#bindings-and-symbols">Bindings and symbols</a></li>
<li><a href="#did-you-say-naming-conventions">Did you say naming conventions?</a></li>
<li><a href="#what-is-a-package">What is a package?</a></li>
<li><a href="#how-do-symbols-get-added-to-a-package">How do symbols get added to a package?</a></li>
<li><a href="#print-read-consistency">Print-read consistency</a></li>
<li><a href="#whats-in-cl-user">What's in CL-USER?</a></li>
<li><a href="#playing-around-with-some-sample-packages">Playing around with some sample packages</a></li>
<li><a href="#package-designators">Package designators</a></li>
<li><a href="#whats-the-deal-with-the-keyword-package">What's the deal with the KEYWORD package?</a></li>
<li><a href="#can-a-symbol-be-homeless">Can a symbol be homeless?</a></li>
<li><a href="#symbols-and-macros">Symbols and macros</a></li>
<li><a href="#special-symbols-t-and-nil">Special symbols: T and NIL</a></li>
<li><a href="#when-i-compile-a-function-how-does-slime-know-which-package-its-in">When I compile a function, how does SLIME know which package it's in?</a></li>
</ul>
</div>
<h2 id="what-is-a-symbol">What is a symbol?</h2>
<p>When it comes to definitions, it's helpful to consult Common Lisp's ANSI specification, published in 1994. <a href="https://www.lispworks.com/documentation/HyperSpec/Body/t_symbol.htm">Quote</a>:</p>
<blockquote>
<p>Symbols are used [...] to name various entities in Common Lisp, including (but not limited to) linguistic entities such as variables and functions.</p>
</blockquote>
<p>In other words, a symbol is a data structure for identifying things. It's important to emphasise that <strong>symbols are not strings</strong>. Each symbol has an associated name, which is represented as a string, but the symbol itself is not a string. I point this out because strings are the closest primitive data type to symbols in most other programming languages.</p>
<h2 id="what-is-to-be-done-with-symbols">What is to be done... with symbols?</h2>
<p>If we enter just "x" at the REPL, the symbol of that name will be evaluated, with the result being the <strong>value</strong> referred to by that symbol.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">defparameter</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">[...]</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="nv">x</span>
<span class="mi">1</span>
</code></pre></div>

<p>To get at the symbol itself, we need to <code>quote</code> it so that it doesn't get evaluated, like <code>(quote x)</code>, or <code>'x</code> for short. Let's use this knowledge to test the statement above, that a symbol is NOT the same as its name. We need the <code>symbol-name</code> function to fetch the name from a symbol data structure.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">type-of</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="nv">SYMBOL</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">symbol-name</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="s">&quot;X&quot;</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">equal</span> <span class="ss">&#39;x</span> <span class="p">(</span><span class="nb">symbol-name</span> <span class="ss">&#39;x</span><span class="p">))</span>
<span class="no">NIL</span>     <span class="c1">; not equal!</span>
</code></pre></div>

<p>At read time, when the raw Lisp code is slurped in and parsed, all occurrences of a particular name are mapped to a single, unique symbol. And so, in the next example, we're comparing the same symbol to itself.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">equal</span> <span class="ss">&#39;x</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="no">T</span>    <span class="c1">; equal</span>
</code></pre></div>

<p>Common Lisp follows the <a href="https://stackoverflow.com/questions/4578574/what-is-the-difference-between-lisp-1-and-lisp-2">Lisp-2 model</a>, so functions and variables have separate namespaces. As such, a symbol can simultaneously identify both a function, which we fetch with <code>symbol-function</code>, and a variable, which we fetch with <code>symbol-value</code>. In the following example, the symbol <code>porridge</code> refers to both a function and a variable.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">;; Define function.</span>
<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">porridge</span> <span class="p">()</span>
      <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
<span class="nv">[...]</span>

<span class="c1">;; Define variable.</span>
<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">defparameter</span> <span class="nv">porridge</span> <span class="mi">10</span><span class="p">)</span>
<span class="nv">[...]</span>

<span class="c1">;; Symbol now refers to both a function and a variable.</span>
<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="ss">&#39;porridge</span><span class="p">)</span>
<span class="mi">10</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;porridge</span><span class="p">)</span>
<span class="err">#</span><span class="nv">&lt;FUNCTION</span> <span class="nv">PORRIDGE&gt;</span>

<span class="c1">;; Compare the above to evaluating the symbol...</span>
<span class="nv">&gt;&gt;&gt;</span> <span class="nv">porridge</span>
<span class="mi">10</span>

<span class="c1">;; ...or invoking the function it identifies.</span>
<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nv">porridge</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></div>

<p><code>(boundp 's)</code> and <code>(fboundp 's)</code> identify whether the symbol <code>s</code> is currently bound to a value or function, respectively. <code>(makunbound 's)</code> and <code>(fmakunbound 's)</code> remove the binding.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">defparameter</span> <span class="nv">x</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">X</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">boundp</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="no">T</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">fboundp</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="no">NIL</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">makunbound</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="nv">[...]</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">boundp</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="no">NIL</span>
</code></pre></div>

<p>Each symbol also has an associated <a href="https://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#property_list">property list</a>, accessed with <code>symbol-plist</code>, but that doesn't rear its head very often. There's also <code>symbol-package</code>, which we'll discuss later.</p>
<h2 id="why-is-the-symbol-name-in-all-caps">Why is the symbol name in all-caps?</h2>
<p>Good catch: we entered the symbol <code>'x</code>, but the printed symbol name was <code>"X"</code>. By default, all symbol names are converted to upper case by the so-called Lisp Reader. This can be controlled with a parameter called <a href="https://www.lispworks.com/documentation/HyperSpec/Body/23_ab.htm">readtable-case</a>, which, if you really want to preserve your precious little capitalisation, can be set to <code>:preserve</code>.</p>
<p>Honestly, I think this is one of the language's biggest warts. Under the default behaviour, if you're trying to implement a formula that contains - <em>gasp</em> - both <code>n</code> AND <code>N</code>, you're reduced to mutating one of the names, as if you were a wretched internet user trying to meet password requirements by going from "password" to "Password1!". I'm not sure why this behaviour was chosen as the default, but usually such things can be blamed on the ANSI standard having to maintain backward compatibility with pre-existing Lisp dialects.</p>
<p>That said, there's a way to preserve case in symbol names regardless of <code>readtable-case</code>. Wrap the name in <code>|</code>s, like <code>'|x|</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">symbol-name</span> <span class="ss">&#39;|hi|</span><span class="p">)</span>
<span class="s">&quot;hi&quot;</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;hi</span> <span class="ss">&#39;|hi|</span><span class="p">)</span>
<span class="no">NIL</span>   <span class="c1">; they have different names</span>
</code></pre></div>

<h2 id="_-is-a-symbol">&lt;_%&amp;? is a symbol</h2>
<p>The rules for symbol names are somewhat unusual, compared to other programming languages. Case in point: <code>&lt;_%&amp;?</code> is a valid symbol name.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">symbol-name</span> <span class="ss">&#39;&lt;_%&amp;?</span><span class="p">)</span>
<span class="s">&quot;&lt;_%&amp;?&quot;</span>
</code></pre></div>

<p>What are these rules? They're described in <a href="https://www.lispworks.com/documentation/HyperSpec/Body/02_a.htm">Section 2.1</a> of the spec, and were admirably summarised by ScottBurson on Reddit -- now reproduced here with their permission.</p>
<p>Any consecutive sequence of characters will be parsed as a symbol, except:</p>
<ul>
<li>whitespace.</li>
<li>parentheses/braces/brackets.</li>
<li>those that can be parsed as numbers.</li>
<li>those starting with certain special characters, including <code>'</code>, <code>`</code>, <code>,</code>, and <code>#</code>.</li>
<li>a single period by itself (called "dot").</li>
</ul>
<p>As exceptions to these exceptions:</p>
<ul>
<li>any sequence of characters surrounded by <code>|</code> is parsed as a symbol.</li>
<li>the non-symbol meaning of any character (including <code>|</code>) can be suppressed by preceding it with <code>\</code>.</li>
</ul>
<p>Following the rules above, here are some valid symbols: <code>foo</code>, <code>foo-bar</code>, <code>=</code>, <code>&lt;_%&amp;?</code>, <code>23-and-me</code>, <code>|(|</code>, and <code>\(</code>.</p>
<h2 id="the-secrets-of-the-defun">The secrets of the defun</h2>
<p>Y'know how symbols have a <code>symbol-function</code> property? We can overwrite the value of this property with <code>setf</code>. That's essentially what <code>defun</code> is doing behind the scenes.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;porridge</span><span class="p">)</span>
          <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
<span class="nv">[...]</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nv">porridge</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></div>

<p>This enables us to reimplement <code>defun</code> as a macro, a somewhat cool fact that was first demonstrated to me in the book <em>On Lisp</em>.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">mydefun</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">parameters</span> <span class="k">&amp;body</span> <span class="nv">body</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">symbol-function</span> <span class="ss">&#39;,name</span><span class="p">)</span>
         <span class="p">(</span><span class="k">lambda</span> <span class="o">,</span><span class="nv">parameters</span> <span class="o">,@</span><span class="nv">body</span><span class="p">)))</span>
</code></pre></div>

<h2 id="bindings-and-symbols">Bindings and symbols</h2>
<p>Based on what we've covered already, it'd be reasonable to expect the following code to work.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">symbol-value</span> <span class="ss">&#39;x</span><span class="p">))</span>
</code></pre></div>

<p>But instead this raises an error about <code>x</code> being unbound.</p>
<p>Here's why: the <code>let</code> form creates a <a href="https://www.lispworks.com/documentation/HyperSpec/Body/26_glo_b.htm#binding">lexical binding</a> between the symbol <code>x</code> and the value <code>1</code>, which persists throughout the body of the <code>let</code>. This is comparable to declaring a local variable in other languages. It doesn't affect the <em>global</em> value of <code>x</code>, which is what <code>symbol-value</code> attempts to retrieve, and hence the error.</p>
<p>If <code>x</code> has already been declared a dynamic (a.k.a. global) variable, however, then the binding created by <code>let</code> will shadow whatever global value <code>x</code> has. Other binding constructs within the language work the same way, e.g. a function parameter called <code>x</code> would also shadow the global variable.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">defparameter</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">[...]</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">5</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">symbol-value</span> <span class="ss">&#39;x</span><span class="p">))</span>
<span class="mi">5</span>

<span class="nv">&gt;&gt;&gt;</span> <span class="p">(</span><span class="nb">symbol-value</span> <span class="ss">&#39;x</span><span class="p">)</span>
<span class="mi">1</span>
</code></pre></div>

<p>(The exact details around variables, bindings, lexical scope, dynamic scope, etc. are beyond the scope of this article).</p>
<p>"Wow," you might be thinking, "Doesn't this make it easy to accidentally mutate a global variable?". Well, yes. That's why, similar to most other programming languages, Common Lisp has a naming convention for global variables. They're given "earmuffs", so that <code>x</code> becomes <code>*x*</code>.</p>
<h2 id="did-you-say-naming-conventions">Did you say naming conventions?</h2>
<p>Yes, the Common Lisp community has adopted a number of <a href="https://www.cliki.net/Naming+conventions">naming conventions</a>. Some that I'll highlight here:</p>
<ul>
<li><code>*x*</code> is a global variable.</li>
<li><code>+x+</code> is a constant.</li>
<li><code>funcp</code> or <code>func-p</code> is a <em>predicate</em> function, i.e. it returns a truthy or falsey value. I much prefer the Scheme convention, <code>func?</code>.</li>
<li>Check out that cliki page for more!</li>
</ul>
<h2 id="what-is-a-package">What is a package?</h2>
<p>It's impossible to get a full picture of how symbols work without also understanding the related concept of <strong>packages</strong>. These are somewhat like namespaces or "packages" in other languages, except they're an actual data structure that we can directly query and manipulate.</p>
<p>Again <a href="https://www.lispworks.com/documentation/HyperSpec/Body/t_pkg.htm">quoting</a> the spec:</p>
<blockquote>
<p>A package is a namespace that maps symbol names to symbols [...]</p>
</blockquote>
<p>The main use case of packages is that they allow <em>your</em> implementation of <code>fizzbuzz</code> to live alongside <em>my</em> <code>fizzbuzz</code>. If our packages are named <code>apple</code> and <code>banana</code>, and they both export a symbol called <code>fizzbuzz</code> for external use, then those symbols are referenced using <code>apple:fizzbuzz</code> and <code>banana:fizzbuzz</code>.</p>
<p>Note that packages don't have any notion of variables or functions, only symbols. That's why they're sometimes described as a "bag of symbols".</p>
<p>Once a package has been created inside a running Lisp process, it's visible everywhere. If there's a package called <code>scooby</code>, and it exports the symbol <code>doo</code>, then that symbol can be referenced anywhere via <code>scooby:doo</code>, with no restrictions.</p>
<h2 id="how-do-symbols-get-added-to-a-package">How do symbols get added to a package?</h2>
<p>When the Lisp Reader inhales some Lisp code, it has to map each symbol name to a symbol data structure. It does this by "interning" each name into the currently active package, which is designated by a global variable called <a href="https://www.lispworks.com/documentation/HyperSpec/Body/v_pkg.htm#STpackageST">*package*</a>. <code>(intern "HI")</code> returns the existing symbol called "hi" if it already exists in <code>*package*</code>; otherwise, it adds a new symbol named "hi" to <code>*package*</code> and returns it. This behaviour ensures that each occurrence of a symbol name will map to the same symbol data structure.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">intern</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span>
<span class="nv">|hi|</span>   <span class="c1">; note: intern doesn&#39;t capitalise names</span>

<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;|hi|</span> <span class="p">(</span><span class="nb">intern</span> <span class="s">&quot;hi&quot;</span><span class="p">))</span>
<span class="no">T</span>      <span class="c1">; they&#39;re the same symbol</span>
</code></pre></div>

<p>("CL-USER&gt;" is the command prompt from the SLIME REPL, indicating that CL-USER is the currently active package).</p>
<p>Programs always start in the COMMON-LISP-USER package, which also goes by the nickname CL-USER. This package gives access to all the symbols you know and love from the ANSI spec: <code>car</code>, <code>cdr</code>, <code>loop</code>, <code>defun</code>, etc. We'll explore CL-USER in more detail later on. The macro <code>(in-package &lt;package-name&gt;)</code> changes the currently active package.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="vg">*package*</span>
<span class="err">#</span><span class="nv">&lt;PACKAGE</span> <span class="s">&quot;COMMON-LISP-USER&quot;</span><span class="nb">&gt;</span>

<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">in-package</span> <span class="ss">:derp</span><span class="p">)</span>
<span class="err">#</span><span class="nv">&lt;PACKAGE</span> <span class="s">&quot;DERP&quot;</span><span class="nb">&gt;</span>

<span class="nv">DERP&gt;</span> <span class="vg">*package*</span> 
<span class="err">#</span><span class="nv">&lt;PACKAGE</span> <span class="s">&quot;DERP&quot;</span><span class="nb">&gt;</span> <span class="c1">; DERP is now the active package</span>
</code></pre></div>

<p>By default, <code>intern</code> adds the symbol to the currently active package, but we can specify a different package. Let's say there's a package called <code>BEANS</code>. Then...</p>
<div class="codehilite"><pre><span></span><code><span class="c1">;; Add symbol named TOAST to the BEANS package.</span>
<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">intern</span> <span class="s">&quot;TOAST&quot;</span> <span class="p">(</span><span class="nb">find-package</span> <span class="s">&quot;BEANS&quot;</span><span class="p">))</span>
<span class="nv">BEANS::TOAST</span>  <span class="c1">; double colon because BEANS doesn&#39;t export TOAST</span>

<span class="c1">;; Switch to the BEANS package.</span>
<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">in-package</span> <span class="nv">beans</span><span class="p">)</span>
<span class="err">#</span><span class="nv">&lt;COMMON-LISP:PACKAGE</span> <span class="s">&quot;BEANS&quot;</span><span class="nb">&gt;</span>

<span class="c1">;; Now we can access the TOAST symbol we added earlier.</span>
<span class="nv">BEANS&gt;</span> <span class="p">(</span><span class="nb">find-symbol</span> <span class="s">&quot;TOAST&quot;</span><span class="p">)</span>
<span class="nv">TOAST</span>
</code></pre></div>

<p>We've used <code>find-package</code> and <code>find-symbol</code> here, which are hopefully self-explanatory. We couldn't just evaluate <code>(quote toast)</code> to verify that the symbol exists, because in the process of reading that form, the <code>toast</code> symbol would be created and added to the active package by the Lisp Reader.</p>
<h2 id="print-read-consistency">Print-read consistency</h2>
<p>If you're confused by the printed representation of symbols, it might be due to print-read consistency, described by The Complete Idiot's Guide as follows:</p>
<blockquote>
<p>One of the invariants that Common Lisp tries to maintain is a property called print-read consistency. This property says that if you print a symbol, and then read the resulting printed representation of that symbol, the result is the same symbol, with two caveats: 1) this does not apply to uninterned symbols, and 2) [...]</p>
</blockquote>
<p>(To find out the other caveat, go read the original ;)</p>
<p>For example, in our demonstration of the <code>intern</code> function, the <code>toast</code> symbol was printed as "BEANS::TOAST" when we were in the CL-USER package, while within the BEANS package it was printed as "TOAST". This is because <code>toast</code> is <em>internal</em> to the BEANS package, and to reference it from outside the BEANS package, we have to use that double colon. If BEANS happened to export the <code>toast</code> symbol, we'd only need 1 colon and the printed representation from CL-USER would be "BEANS:TOAST". <em>Within</em> the BEANS package, we don't need a package prefix, hence why it's just "TOAST".</p>
<h2 id="whats-in-cl-user">What's in CL-USER?</h2>
<p>It can be nice to explore this sort of question in the SLIME inspector. If you happen to have a SLIME REPL open in Emacs, enter <code>(find-package "COMMON-LISP-USER")</code> or <code>(find-package "CL-USER")</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">find-package</span> <span class="s">&quot;COMMON-LISP-USER&quot;</span><span class="p">)</span>
<span class="err">#</span><span class="nv">&lt;PACKAGE</span> <span class="s">&quot;COMMON-LISP-USER&quot;</span><span class="nb">&gt;</span>
</code></pre></div>

<p>Now right click on the output, click "Inspect", and you should see something like the following.</p>
<div class="codehilite"><pre><span></span><code>#&lt;PACKAGE {1000013983}&gt;
--------------------
Name: &quot;COMMON-LISP-USER&quot;
Nicknames: &quot;CL-USER&quot;
Documentation:
public: the default package for user code and data
Use list: COMMON-LISP, SB-ALIEN, SB-DEBUG, SB-EXT, SB-GRAY, SB-PROFILE
Used by list: [nothing here]
4 present symbols.
0 external symbols.
4 internal symbols.
1329 inherited symbols.
0 shadowed symbols.
</code></pre></div>

<p>We see the package's name, its nicknames, and its documentation. Then there's the "Use list", containing all the packages that COMMON-LISP-USER inherits symbols from. My CL-USER package inherits from COMMON-LISP, as well as various packages defined by the SBCL implementation of Common Lisp, which I happen to be using. The symbols from the ANSI spec live in the COMMON-LISP package, which we can confirm with <code>symbol-package</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">symbol-package</span> <span class="ss">&#39;car</span><span class="p">)</span>
<span class="err">#</span><span class="nv">&lt;PACKAGE</span> <span class="s">&quot;COMMON-LISP&quot;</span><span class="nb">&gt;</span>
</code></pre></div>

<p>(<code>symbol-package</code> tells us the "home package" of a symbol; that is, where it was initially interned).</p>
<p>Next in the inspector output, we see that CL-USER has 4 "present" symbols, which are symbols whose home package is CL-USER. We can check which symbols those are as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">do-symbols</span> <span class="p">(</span><span class="nv">s</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">symbol-package</span> <span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">find-package</span> <span class="s">&quot;CL-USER&quot;</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~a~%&quot;</span> <span class="nv">s</span><span class="p">)))</span>
<span class="nv">BEANS</span>
<span class="nv">S</span>
<span class="nv">hi</span>
<span class="nv">QUICKLISP-INIT</span>
<span class="nv">HI</span>
</code></pre></div>

<p>(In the course of evaluating this, the Lisp Reader interned another symbol, <code>S</code>, into CL-USER, and so now there are 5 present symbols).</p>
<p>Back to the inspector output. CL-USER doesn't export any symbols, so all 4 (now 5) of the present symbols are "internal symbols". Then there are 1329 inherited symbols from COMMON-LISP and the SBCL packages. We don't shadow any of those symbols. Shadowing allows you, for example, to define your own implementation of <code>car</code> or <code>+</code>, but it's usually considered a bad idea, since it subverts people's expectations of what those symbols refer to.</p>
<h2 id="playing-around-with-some-sample-packages">Playing around with some sample packages</h2>
<p>Let's define a package called <code>beatles</code>. The most common way to do this is via the <code>defpackage</code> macro, which has a number of options.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">defpackage</span> <span class="nv">beatles</span>
  <span class="p">(</span><span class="ss">:use</span> <span class="ss">:cl</span><span class="p">)</span>
  <span class="p">(</span><span class="ss">:export</span> <span class="ss">:play</span><span class="p">))</span>
</code></pre></div>

<p>The options we've used here:</p>
<ul>
<li><code>(:use :cl)</code> -- This makes BEATLES inherit all the exported symbols from the COMMON-LISP package (nicknamed CL). You'll almost always want to do this, because otherwise you'll have to prefix all the spec-defined symbols with <code>cl:</code>.</li>
<li><code>(:export :play)</code> -- Exporting a symbol makes it visible outside the package. We're going to define a <code>play</code> function inside the BEATLES package and export the symbol.</li>
</ul>
<p>Why do many of these symbols have a colon as a prefix? This is a special syntax for referencing "keywords", which are symbols in the <a href="https://www.lispworks.com/documentation/HyperSpec/Body/11_abc.htm">KEYWORD package</a>. A common use of keyword symbols is to avoid flooding a package namespace with symbols that will never be used again. If we wrote this defpackage form without keyword symbols, then symbols called <code>cl</code> and <code>play</code> would be pointlessy interned into the CL-USER package (or whichever package is active). In fact, as it stands, we're pointlessly interning the <code>beatles</code> symbol. We could avoid this by writing <code>(defpackage :beatles ...)</code> instead. The same applies for calls to <code>find-package</code>, as <code>(find-package :beatles)</code> works just as well as <code>(find-package 'beatles)</code> or <code>(find-package "BEATLES")</code>.</p>
<p>Anyway, let's now define some functions in the BEATLES package. Since the <code>play</code> symbol is exported, the function it identifies will be available outside the package.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">in-package</span> <span class="nv">beatles</span><span class="p">)</span> <span class="c1">; or (in-package :beatles)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">play</span> <span class="p">()</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;badum tss~%&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sing</span> <span class="p">()</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;she loves you yeah yeah yeah~%&quot;</span><span class="p">))</span>
</code></pre></div>

<p>Now let's define another package, STONES, which inherits symbols from the BEATLES package as well as CL.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">defpackage</span> <span class="ss">:stones</span>
  <span class="p">(</span><span class="ss">:use</span> <span class="ss">:cl</span> <span class="ss">:beatles</span><span class="p">))</span>

<span class="p">(</span><span class="nb">in-package</span> <span class="ss">:stones</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sing</span> <span class="p">()</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;something something paint it black~%&quot;</span><span class="p">))</span>
</code></pre></div>

<p>This diagram represents how I think about packages. I will be gravely insulted if you don't find it helpful. The stickperson represents the active package.</p>
<p><img src="/static/img/cl-packages/example.png"
     alt="3 boxes labelled 'common-lisp-user', 'beatles' and 'stones'. The first contains a stick figure and a few symbols: 'car, 'cdr, etc. The 'beatles' box contains 'play, 'sing, 'car (from CL), etc. The 'stones box contains 'play (from 'beatles'), 'sing, 'car (from CL), etc."
     class="centered"></p>
<p>We start off in CL-USER. The BEATLES package exports the <code>play</code> symbol, so we can call the function it identifies, but we don't have access to the <code>sing</code> symbol.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nv">beatles:play</span><span class="p">)</span>
<span class="nv">badum</span> <span class="nv">tss</span>
<span class="no">NIL</span>

<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nv">beatles:sing</span><span class="p">)</span>
<span class="c1">; (Error: The symbol SING is not external in the BEATLES package.)</span>
</code></pre></div>

<p>If we REALLY want to access an internal symbol from a package, we can use double colon syntax. However, it's usually a bad idea to circumvent the interface of a package like that.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nv">beatles::sing</span><span class="p">)</span>
<span class="nv">she</span> <span class="nv">loves</span> <span class="nv">you</span> <span class="nv">yeah</span> <span class="nv">yeah</span> <span class="nv">yeah</span>
<span class="no">NIL</span>
</code></pre></div>

<p>The STONES package doesn't export any symbols, so we can't access its implementation of <code>sing</code>. Let's try making it the active package.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">in-package</span> <span class="ss">:stones</span><span class="p">)</span>
<span class="err">#</span><span class="nv">&lt;PACKAGE</span> <span class="s">&quot;STONES&quot;</span><span class="nb">&gt;</span>

<span class="nv">STONES&gt;</span> <span class="vg">*package*</span>
<span class="err">#</span><span class="nv">&lt;PACKAGE</span> <span class="s">&quot;STONES&quot;</span><span class="nb">&gt;</span>
</code></pre></div>

<p>Since STONES inherits symbols from BEATLES, we can call the BEATLES implementation of <code>play</code>. Also check to make sure it's really coming from BEATLES.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">STONES&gt;</span> <span class="p">(</span><span class="nv">play</span><span class="p">)</span>
<span class="nv">badum</span> <span class="nv">tss</span>
<span class="no">NIL</span>

<span class="nv">STONES&gt;</span> <span class="p">(</span><span class="nb">symbol-package</span> <span class="ss">&#39;play</span><span class="p">)</span>
<span class="err">#</span><span class="nv">&lt;PACKAGE</span> <span class="s">&quot;BEATLES&quot;</span><span class="nb">&gt;</span>
</code></pre></div>

<p>STONES didn't inherit the <code>sing</code> symbol from BEATLES, but instead defined its own implementation of <code>sing</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">STONES&gt;</span> <span class="p">(</span><span class="nv">sing</span><span class="p">)</span>
<span class="nv">something</span> <span class="nv">something</span> <span class="nv">paint</span> <span class="nv">it</span> <span class="nv">black</span>
<span class="no">NIL</span>

<span class="nv">STONES&gt;</span> <span class="p">(</span><span class="nb">symbol-package</span> <span class="ss">&#39;sing</span><span class="p">)</span>
<span class="err">#</span><span class="nv">&lt;PACKAGE</span> <span class="s">&quot;STONES&quot;</span><span class="nb">&gt;</span>
</code></pre></div>

<p>BEATLES and STONES share a single symbol by the name of "PLAY", since it was interned into BEATLES and then imported by STONES. In contrast, "SING" was interned separately into both packages and is mapped to two distinct symbols.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">STONES&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">find-symbol</span> <span class="s">&quot;PLAY&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">find-symbol</span> <span class="s">&quot;PLAY&quot;</span> <span class="p">(</span><span class="nb">find-package</span> <span class="ss">:beatles</span><span class="p">)))</span>
<span class="no">T</span>

<span class="nv">STONES&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">find-symbol</span> <span class="s">&quot;SING&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">find-symbol</span> <span class="s">&quot;SING&quot;</span> <span class="p">(</span><span class="nb">find-package</span> <span class="ss">:beatles</span><span class="p">)))</span>
<span class="no">NIL</span>
</code></pre></div>

<h2 id="package-designators">Package designators</h2>
<p>We've seen that macros/functions like <code>defpackage</code> and <code>find-package</code> accept various data types as references to a package, including symbols, keywords and strings. These are collectively referred to as <a href="https://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#package_designator">package designators</a>, defined in the standard as:</p>
<blockquote>
<p>a designator for a package; that is, an object that denotes a package and that is one of: a string designator (denoting the package that has the string that it designates as its name or as one of its nicknames), or a package (denoting itself).</p>
</blockquote>
<p>A <a href="https://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#string_designator">string designator</a>, in turn, is defined as:</p>
<blockquote>
<p>a designator for a string; that is, an object that denotes a string and that is one of: a character (denoting a singleton string that has the character as its only element), a symbol (denoting the string that is its name), or a string (denoting itself). The intent is that this term be consistent with the behavior of string; implementations that extend string must extend the meaning of this term in a compatible way.</p>
</blockquote>
<p>Here's a potential gotcha. You might think that <code>(defpackage 'apple [...])</code> is a valid call to <code>defpackage</code>, because <code>'apple</code> is a symbol, which is a package designator! But actually, <code>'apple</code> is short for <code>(quote apple)</code>, which is a list and decidedly NOT a package designator. When we <em>evaluate</em> <code>(quote apple)</code>, it returns the symbol called "APPLE", which would be a valid package designator, but when we pass <code>(quote apple)</code> to a macro then the macro just sees a list.</p>
<h2 id="whats-the-deal-with-the-keyword-package">What's the deal with the KEYWORD package?</h2>
<p>We've already touched briefly on the KEYWORD package. In brief: keywords are symbols in the KEYWORD package, and <code>:blah</code> is syntax sugar for <code>keyword:blah</code>. But besides avoiding namespace pollution, what are keywords good for?</p>
<p><a href="https://www.lispworks.com/documentation/HyperSpec/Body/11_abc.htm">Quoting the spec</a>:</p>
<blockquote>
<p>The KEYWORD package contains symbols, called keywords, that are typically used as special markers in programs and their associated data expressions. </p>
</blockquote>
<p>There are a few examples of keywords being used as "special markers", one of which is the use of keyword parameters in functions.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">;; Defining a function with a keyword parameter.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">(</span><span class="k">&amp;key</span> <span class="p">(</span><span class="nv">x</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1">;; Here be a wild keyword!</span>
<span class="p">(</span><span class="nv">foo</span> <span class="ss">:x</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; ---&gt; 5</span>
</code></pre></div>

<p>Another insightful quote from the spec...</p>
<blockquote>
<p>Symbol tokens that start with a package marker are parsed by the Lisp reader as symbols in the KEYWORD package; see Section 2.3.4 (Symbols as Tokens). This makes it notationally convenient to use keywords when communicating between programs in different packages. For example, the mechanism for passing keyword parameters in a call uses keywords to name the corresponding arguments [...]</p>
</blockquote>
<p>Here's an example of how keywords are convenient for "communicating between programs in different packages". Let's say the BEATLES package exports a <code>favourite</code> macro that generates a print statement based on the code it receives.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">in-package</span> <span class="ss">:beatles</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defmacro</span> <span class="nv">favourite</span> <span class="p">(</span><span class="nv">beatle</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">beatle</span> <span class="ss">:john</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;correct~%&quot;</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;wrong~%&quot;</span><span class="p">)))</span>
</code></pre></div>

<p>If we now call this macro from the STONES package...</p>
<div class="codehilite"><pre><span></span><code><span class="nv">STONES&gt;</span> <span class="p">(</span><span class="nv">beatles:favourite</span> <span class="ss">:john</span><span class="p">)</span>
<span class="nv">correct</span>

<span class="nv">STONES&gt;</span> <span class="p">(</span><span class="nv">beatles:favourite</span> <span class="ss">:ringo</span><span class="p">)</span>
<span class="nv">wrong</span>
</code></pre></div>

<p>...it behaves as we'd expect. If we'd instead implemented <code>favourite</code> using the comparison <code>(eq beatle 'john)</code>, then <code>(beatles:favourite 'john)</code> and <code>(beatles:favourite 'ringo)</code> would, perhaps surprisingly, <em>both</em> print "wrong", because the <code>john</code> symbol we'd be interning into the STONES package would be different to the <code>john</code> symbol in the BEATLES package.</p>
<p>In an act of unashamed plagiarism, here's a lazy quote of more usage advice from the spec that I thought was interesting:</p>
<blockquote>
<p>It is generally best to confine the use of keywords to situations in which there are a finitely enumerable set of names to be selected between. For example, if there were two states of a light switch, they might be called :on and :off. </p>
<p>In situations where the set of names is not finitely enumerable (i.e., where name conflicts might arise) it is frequently best to use symbols in some package other than KEYWORD so that conflicts will be naturally avoided. For example, it is generally not wise for a program to use a keyword as a property indicator, since if there were ever another program that did the same thing, each would clobber the other's data. </p>
</blockquote>
<h2 id="can-a-symbol-be-homeless">Can a symbol be homeless?</h2>
<p>We've seen how symbols have a home package, which is the package into which they were originally interned. <code>(symbol-package 'sym)</code> yields this package. Here are some ways in which a symbol can become orphaned, such that <code>(symbol-package 'sym)</code> returns <code>NIL</code>.</p>
<p>1) Manually create a symbol data structure: <code>(make-symbol "NAME-HERE")</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">symbol-package</span> <span class="p">(</span><span class="nb">make-symbol</span> <span class="s">&quot;jinkies&quot;</span><span class="p">))</span>
<span class="no">NIL</span>
</code></pre></div>

<p>2) Syntax sugar for homeless symbols: <code>'#:name-here</code>. Note that <code>(eq '#:hi '#:hi)</code> returns <code>NIL</code>, since they're different symbols that just happen to share the same name. It's only within packages that each name is mapped to a unique symbol. If you want to be miserly about the number of junk symbols you're creating, then you can use these orphan symbols to denote package and symbol names in <code>defpackage</code>, <code>find-package</code>, <code>in-package</code> and elsewhere. I find it a bit verbose, though...</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">defpackage</span> <span class="ss">#:beatles</span>
  <span class="p">(</span><span class="ss">:use</span> <span class="ss">#:cl</span><span class="p">)</span>
  <span class="p">(</span><span class="ss">:export</span> <span class="ss">#:play</span><span class="p">))</span>

<span class="p">(</span><span class="nb">find-package</span> <span class="o">&#39;</span><span class="ss">#:beatles</span><span class="p">)</span>
</code></pre></div>

<p>3) <code>unintern</code> a symbol to remove it from a package:</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">find-symbol</span> <span class="s">&quot;S&quot;</span><span class="p">)</span>
<span class="nv">S</span>         <span class="c1">; it exists!</span>
<span class="ss">:INTERNAL</span> <span class="c1">; and is not exported</span>

<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">unintern</span> <span class="ss">&#39;s</span><span class="p">)</span>
<span class="no">T</span>

<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">find-symbol</span> <span class="s">&quot;S&quot;</span><span class="p">)</span>
<span class="no">NIL</span>       <span class="c1">; it does not exist anymore!</span>
<span class="no">NIL</span>
</code></pre></div>

<h2 id="symbols-and-macros">Symbols and macros</h2>
<p>Here's an example that should demonstrate the relationship between symbols, the Lisp Reader, and macros. Perhaps you're like me and came up with the ingenious idea of a macro that executes its body inside a certain package, before restoring the original active package. Something like...</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nv">with-package</span> <span class="ss">:beatles</span>
  <span class="p">(</span><span class="nv">play</span><span class="p">))</span>
</code></pre></div>

<p>And here's how you might imagine implementing this.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">with-package</span> <span class="p">(</span><span class="nv">name</span> <span class="k">&amp;body</span> <span class="nv">body</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">old-pkg</span> <span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
    <span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="o">,</span><span class="nv">old-pkg</span> <span class="vg">*package*</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="vg">*package*</span> <span class="p">(</span><span class="nb">find-package</span> <span class="o">,</span><span class="nv">name</span><span class="p">))</span>
       <span class="o">,@</span><span class="nv">body</span>
       <span class="p">(</span><span class="nb">setf</span> <span class="vg">*package*</span> <span class="o">,</span><span class="nv">old-pkg</span><span class="p">))))</span>
</code></pre></div>

<p>Now, the above code should expand to something like...</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="ss">#:g690</span> <span class="vg">*package*</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="vg">*package*</span> <span class="p">(</span><span class="nb">find-package</span> <span class="ss">:beatles</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">play</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="vg">*package*</span> <span class="ss">#:g690</span><span class="p">))</span>
</code></pre></div>

<p>...where <code>#:g690</code> is a unique, homeless symbol produced for us by <code>gensym</code>.</p>
<p>The problem with this idea is that it represents a misunderstanding of how code execution works in Common Lisp. For the sake of simplification, let's say that code execution consists of two stages: Reading and Evaluation. First, raw text is guzzled up by the Lisp Reader and converted to Lisp data structures. It's in this stage that symbols are created, and it's here that their home package is determined, based on the value of <code>*package*</code> when Reading occurs. Next comes Evaluation, which begins with the expansion of all macros in the code. Macros are functions that operate on Lisp data structures and return Lisp data structures. By the time our <code>with-package</code> macro is passed the list <code>((play))</code> as its <code>body</code> parameter, it's already too late. The <code>play</code> symbol has been interned in whatever package was active when the Lisp Reader did its job, probably CL-USER. It doesn't matter if, when our expanded code is being evaluated, we set <code>*package*</code> before calling <code>(play)</code>, because <code>play</code> has already been interned somewhere else.</p>
<p>All that to say: the Evaluation of a form can't affect how it is read by the Lisp Reader, since Reading happens before Evaluation. We could implement something like <code>with-package</code> using <em>reader macros</em>, but that's a topic for another day.</p>
<h2 id="special-symbols-t-and-nil">Special symbols: T and NIL</h2>
<p>There are two special symbols that evaluate to themselves: <code>t</code> and <code>nil</code>. When we evaluate <code>(symbol-value t)</code>, we get back... <code>t</code> again. These "special symbols" represent various things, including the boolean values true &amp; false. <code>nil</code> also represents the empty list, hence why <code>(listp nil)</code> returns <code>t</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">symbolp</span> <span class="no">t</span><span class="p">)</span>
<span class="no">T</span>   <span class="c1">; it&#39;s a symbol!</span>

<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">symbol-name</span> <span class="no">t</span><span class="p">)</span>
<span class="s">&quot;T&quot;</span> <span class="c1">; I&#39;m not joking, it really is a symbol</span>

<span class="nv">CL-USER&gt;</span> <span class="no">t</span>
<span class="no">T</span>   <span class="c1">; evaluates to itself!</span>

<span class="nv">CL-USER&gt;</span> <span class="p">(</span><span class="nb">symbolp</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">T</span>

<span class="nv">CL-USER&gt;</span> <span class="no">nil</span>
<span class="no">NIL</span>
</code></pre></div>

<h2 id="when-i-compile-a-function-how-does-slime-know-which-package-its-in">When I compile a function, how does SLIME know which package it's in?</h2>
<p>If you're an Emacs user and you've compiled a single Common Lisp form, like a function, using the <code>C-c C-c</code> shortcut, then you may have wondered how SLIME knows which package should be active when the Lisp Reader slurps in that form. For example, you might have the following code in a buffer:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">in-package</span> <span class="nv">foo</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">bar</span> <span class="p">()</span>
  <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div>

<p>In your REPL, the currently active package is CL-USER. So when you compile the <code>bar</code> function, why does it get added to the FOO package rather than CL-USER?</p>
<p>This is an implementation detail of SLIME more than anything, but I remember being confused by it, so let's indulge ourselves with this brief tangent. First, let's see which Elisp function the <code>C-c C-c</code> shortcut is bound to. Entering the help command for keyboard shortcuts, <code>C-h k</code>, and then <code>C-c C-c</code>, we're told that this shortcut is bound to the function <code>slime-compile-defun</code>.</p>
<p>This function is defined in <code>slime.el</code>. Following the link there and searching for "in-package", we find the following comment:</p>
<blockquote>
<p>We have the concept of the "current Lisp package". RPC requests always say what package the user is making them from and the Lisp side binds that package to *BUFFER-PACKAGE* to use as it sees fit. The current package is defined as the buffer-local value of 'slime-buffer-package' if set, and otherwise the package named by the nearest IN-PACKAGE as found by text search (cl-first backwards, then forwards).</p>
</blockquote>
<p>And there's our answer: unless <code>slime-buffer-package</code> is set, SLIME first searches backwards and then forwards for the nearest IN-PACKAGE form. Not mentioned is that if no IN-PACKAGE form is found, then the code is compiled in the currently active package, whether that's CL-USER or something else.</p>
<p>For curiosity's sake, here's the Elisp function used to search for IN-PACKAGE.</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">slime-search-buffer-package</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">case-fold-search</span> <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">regexp</span> <span class="p">(</span><span class="nv">concat</span> <span class="s">&quot;^[ \t]*(\\(cl:\\|common-lisp:\\)?in-package\\&gt;[ \t&#39;]*&quot;</span>
                        <span class="s">&quot;\\([^)]+\\)[ \t]*)&quot;</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">save-excursion</span>
      <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">re-search-backward</span> <span class="nv">regexp</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
                <span class="p">(</span><span class="nv">re-search-forward</span> <span class="nv">regexp</span> <span class="no">nil</span> <span class="no">t</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">match-string-no-properties</span> <span class="mi">2</span><span class="p">)))))</span>
</code></pre></div>

<hr />

<p><small>With thanks to ScottBurson, stassats, vindarel, zacque0, kagevf, Jamie and Ordy for their feedback on this post.</small></p>
<hr>
<a href="/blog/cl-livecoding.html">&lt;&lt; previous</a>
<ul>
<li><a href="/blog.html">Back to blog</a></li>
<li><a href="/feed.xml">RSS feed</a></li>
</ul>
<p>I'd be happy to hear from you at <i>galligankevinp@gmail.com</i>.</p>

</body>
</html>