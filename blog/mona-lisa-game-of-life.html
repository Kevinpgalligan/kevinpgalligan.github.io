<!doctype html>
<html lang="en">

<head>
    <title> Finding Mona Lisa in the Game of Life </title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="stylesheet" href="/pygments.css">
    
<link rel="stylesheet" href="/static/css/blog.css">

    <link rel="icon" type="image/png" sizes="16x16" href="/static/img/favicon-16x16.png">
    
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-147419708-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-147419708-1');
    </script>
    
</head>
<body>
    <header>
        <div data-nosnippet>
        
        <nav>
        <img src="/static/img/favicon-16x16.png">
        
            <a href="/index.html" class="navlink">home</a>
        
            <a href="/blog.html" class="navlink">blog</a>
        
            <a href="/projects.html" class="navlink">projects</a>
        
        </nav>
        </div>
    </header>

<h2>Finding Mona Lisa in the Game of Life</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a> is like a 2d, grid-shaped petri dish. Each grid square in the dish is a cell that can be either alive or dead.</p>
<p><img src="/static/img/mona-lisa-gol/some-life.gif"
     alt="Evolution of Life for a number of states."
     class="centered"></p>
<p>The petri dish changes state according to simple rules:</p>
<ul>
<li>A dead cell comes to life if it has 3 adjacent cells (or "neighbours") that are alive.</li>
<li>A live cell with more than 3 live neighbours dies due to overcompetition.</li>
<li>A live cell with fewer than 2 live neighbours dies due to loneliness.</li>
</ul>
<p>Picking out any cell in the above animation, you will observe that it lives or dies according to these rules.</p>
<p>Besides resulting in cool-looking patterns, it has been proven that the Game of Life ("Life" for short) can simulate anything that can be done by your computer, whether that's summing numbers or captioning images of cats. Not bad for a petri dish.</p>
<p><img src="/static/img/mona-lisa-gol/spaceship.gif"
     alt="Spaceship pattern moving along in Life"
     class="centered"></p>
<p>What does this have to do with Mona Lisa? It's easy to load a black &amp; white picture as a Life state, where black pixels are live cells and white pixels are dead cells. Effectively, we can simulate a Life state that looks like Mona Lisa. The dark regions of the picture die off immediately due to overpopulation, leaving an outline, which then melts away further and leaves only hints of our precious Mona.</p>
<p><img src="/static/img/mona-lisa-gol/mona-start.gif"
     alt="Evolution of Life with Mona Lisa picture as starting state"
     class="centered"></p>
<p>This looks kinda cool, but what if we want to find a Life state that eventually, after following the rules of Life for a few rounds, reaches a state that looks like Mona Lisa? This requires working backwards from the target picture, which turns out to be a <strong>much</strong> more difficult problem.</p>
<p>In this article, we're going to explore just how difficult the problem is, and how it can be attempted using what are known as "SAT solvers". We'll then look at animations of flowers, Steve Buscemi and other objects of interest that we can generate with the result.</p>
<h3>Life, the Universe and SAT Solvers</h3>
<p>We call Life state A the "parent" of state B if A turns into B by following the rules of Life. The reason that it's difficult to find the parent of a state is that the rules of Life are non-reversible. There's no "reverse rule" that we can apply to always go from a state to its parent state. In fact, it's possible for a state to have multiple parents, or even no parents.</p>
<p>What we <em>can</em> do is construct a boolean equation that captures the conditions that any parent state of our target state must satisfy, then solve it to find a parent, if a parent exists.</p>
<p><img src="/static/img/mona-lisa-gol/scream.gif"
     alt="Evolution of the Scream painting as a Life state"
     class="centered"></p>
<p>(Side note: a boolean equation is an equation where the variables take on true / false values, and where the operators, instead of the pluses and minuses that we usually see, are replaced by boolean operators such as AND and OR. For example, the equation <code>sour AND (NOT sweet)</code> is solved by setting <code>sour=true</code> and <code>sweet=false</code>. <a href="https://en.wikipedia.org/wiki/Boolean_algebra">Read more here</a>).</p>
<p>In the boolean equation that we construct, each variable corresponds to a cell and the value of the variable indicates the state of the cell. False means that the cell is dead, true means alive. If we find a set of cell states that satisfy the equation, i.e. cause it to evaluate to true, then a state with that configuration of cells is actually a parent of our target state.</p>
<p>What will the equation look like? Let's consider a 3x3 Life grid as an example.</p>
<div class="codehilite"><pre><span></span>  1 2 3
a o x x
b x x x
c x o x
</pre></div>


<p>The middle cell, b2, is alive. For it to be alive in this state, it must be the case that either:</p>
<ol>
<li>It was alive in the previous state and 2-3 of its neighbours were also alive.</li>
<li>It was dead in the previous state and 3 of its neighbours were alive.</li>
</ol>
<p>Keeping in mind that true means alive and false means dead, this can be translated to a boolean equation in a fairly literal way.</p>
<div class="codehilite"><pre><span></span>(b2 AND ((a1 AND a2 AND !a3 AND !b1 AND !b3 AND !c1 AND !c2 AND !c3)
         OR (a1 AND !a2 AND a3 AND !b1 AND !b3 AND !c1 AND !c2 AND !c3)
         OR ...repeat 82 more times for other combinations of neighbours))
OR
(!b2 AND ((a1 AND a2 AND a3 AND !b1 AND !b3 AND !c1 AND !c2 AND !c3)
               OR ...repeat 55 more times for other combinations of neighbours))
</pre></div>


<p>So either b2 was true (i.e. alive) and 2-3 of its neighbour variables were true (there being 84 possible assignments to the neighbour variables where 2-3 of them are true), or it was false (i.e. dead) and 3 of its neighbour variables were true (there being 56 possible assignments where 3 of the neighbour variables are true).</p>
<p>If we repeat this construction for every cell in the grid and chain them together using ANDs, we end up with an equation that we can solve to find a parent of the target state. And, as it happens, there are many "SAT-solving" programs that search for solutions to boolean equations. Once we have our equation, we ship it off to our SAT solver of choice and sit back, relaxedly sipping our lattes until it gets back to us with a result.</p>
<h3>Great, let's move on to the pretty pictures</h3>
<p>WAIT. While this is nice in theory, there are significant "buts".</p>
<p>The first "but" is that, as we touched on in the previous section, <em>not all Life states have parents</em>. Such states are known as <a href="https://en.wikipedia.org/wiki/Garden_of_Eden_(cellular_automaton)">Gardens of Eden</a>. If our target picture happens to be a Garden of Eden in Life, then the SAT solver will definitely fail, no matter how good it is. And the larger a Life state, the more likely it is to be a Garden of Eden, because it has more sub-sections that can possibly be in impossible configurations.</p>
<p>The second "but" is that, as the number of cells increases, so too does the difficulty of the problem. Trying to generate a SAT equation for ~1800 cells blew up my program by consuming the entire 1GB of memory that was available to it. The time to find the parent of a Life state also starts to become prohibitive with more than ~400 cells. <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">SAT problems</a>, after all, are in the NP-complete class of problems (which means that they are damn hard to solve with current methods).</p>
<p><img src="/static/img/mona-lisa-gol/cloverleaf.gif"
     alt="Evolution of cloverleaf pattern"
     class="centered"></p>
<p>To demonstrate this, below are the timings I got after finding the parent state (which we will refer to as "backsearch" from now on) of random Life states of varying sizes. My processor is a wimpy i3-8130U 2.20GHz.</p>
<p><img src="/static/img/mona-lisa-gol/cells-vs-backsearch-time.png"
     alt="Time for backsearch vs number of cells, seems to grow exponentially"
     class="centered"></p>
<p>As a result of these "buts", any pictures we use will have to be restricted in size to around 20x20 or less (&lt;=400 cells). Beyond that, the problems are too difficult for my computer to handle, and are often impossible to solve.</p>
<p>Here's the output of backsearch on a modest 13x11 sad face. It manages to find 2 previous states before landing in a Garden of Eden. Interestingly, there's no hint of the sad face in the first state, and not much more in the second state.</p>
<p><img src="/static/img/mona-lisa-gol/sadface.gif"
     alt="Life state becomes sad face, found using backsearch"
     class="centered"></p>
<h3>The results</h3>
<p>Mona Lisa.</p>
<p>GIF HERE.</p>
<p>Marilyn Monroe.</p>
<p>GIF HERE.</p>
<p>A flower.</p>
<p>GIF HERE.</p>
<p>Steve Buscemi.</p>
<p>GIF HERE.</p>
<p>A hamster.</p>
<p>GIF HERE.</p>
<h3>Conclusions</h3>
<p>We have seen that it is possible to find parents of Game of Life states, although it's inherently difficult.</p>
<p>A few possibilities come to mind for optimising the solution:</p>
<ul>
<li>Generate smaller boolean equations that still encode the problem, as described in The Art of Computer Programming, Volume 4, Fascicle 6.</li>
<li>Use a more efficient SAT solver. MiniSat was used here.</li>
<li>If possible, configure the SAT solver to search for solutions with fewer live cells. This might reduce the chances that backsearch will end up in a Garden of Eden.</li>
</ul>
<p>We have now played more than enough with petri dishes for the time being.</p>
<h3>Technical details</h3>
<p><a href="https://github.com/Kevinpgalligan/MonaLisaGameOfLife">The code is here</a>.</p>
<p>The simulations and GIFs from this article were created using Common Lisp. The cl-sat library was used as a wrapper to call the MiniSat SAT solver, while the skippy library was used to create GIFs.</p>
<p>Credit to the #lispgames IRC community for helping me with my silly questions about Common Lisp.</p>
<h3>Further reading</h3>
<p>Some fun stuff I came across while researching this article.</p>
<ul>
<li>My first idea was using evolutionary algorithms to generate interesting patterns in Life, but <a href="https://pdfs.semanticscholar.org/ba77/59e4d871d09459e3751d110137a8434591f6.pdf">this turned out to have been done already</a> by Alfaro, Mendoza and Tice.</li>
<li>I then had the idea to look for specific patterns, such as pictures. Some time was wasted trying to do this using evolutionary algorithms, until it was realised that the problem was equivalent to SAT. And, as it happens, there are already backwards/forwards solvers for Life <a href="https://github.com/flopp/gol-sat">[1]</a><a href="https://www.conwaylife.com/forums/viewtopic.php?f=9&amp;t=3247">[2]</a>, although they don't seem to have been applied to the task of finding pictures.</li>
<li>Backwards solver #2 (from the previous point) mentions The Art of Computer Science, Volume 4, Fascicle 6 as a source of information and exercises on backsearch in Life, although I haven't been able to get my hands on it.</li>
<li>A cool thing: <a href="https://codegolf.stackexchange.com/questions/38573/paint-a-still-life-or-a-moving-one-draw-an-image-in-the-game-of-life">still life paintings in Life</a>.</li>
<li>Another cool thing: <a href="http://tlrobinson.net/blog/2009/02/game-of-life-generator/">text &amp; image generator in Life</a>.</li>
</ul>
<hr>
<p><i>Post Date: 2020-01-19</i></p>
<a href="/blog.html">Back to blog</a>
 <p>No previous article.</p>

 <p>No next article.</p>


</body>
</html>